["7bad47f24fdba1b3f85f6a02e93aa4ce8f6e78d4","09513d795b9de34fd90d6fe964ae8c55c52aab76",["fbjs/lib/invariant","normalizeColor"],[40,92],{"version":3,"sources":["/TryOut/node_modules/react-native/Libraries/Animated/src/Interpolation.js"],"names":["invariant","require","normalizeColor","linear","t","Interpolation","config","outputRange","createInterpolationFromStringOutputRange","checkInfiniteRange","inputRange","checkValidInputRange","length","easing","extrapolateLeft","undefined","extrapolate","extrapolateRight","input","range","findRange","interpolate","inputMin","inputMax","outputMin","outputMax","result","Infinity","colorToRgba","int32Color","r","g","b","a","stringShapeRegex","map","checkPattern","outputRanges","match","forEach","value","number","i","push","interpolations","create","shouldRound","isRgbOrRgba","replace","val","rounded","Math","round","String","startsWith","arr","pattern","name","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) 2015-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule Interpolation\n * @flow\n */\n/* eslint no-bitwise: 0 */\n'use strict';\n\nvar invariant = require('fbjs/lib/invariant');\nvar normalizeColor = require('normalizeColor');\n\ntype ExtrapolateType = 'extend' | 'identity' | 'clamp';\n\nexport type InterpolationConfigType = {\n  inputRange: Array<number>,\n  /* $FlowFixMe(>=0.38.0 site=react_native_fb,react_native_oss) - Flow error\n   * detected during the deployment of v0.38.0. To see the error, remove this\n   * comment and run flow\n   */\n  outputRange: (Array<number> | Array<string>),\n  easing?: ((input: number) => number),\n  extrapolate?: ExtrapolateType,\n  extrapolateLeft?: ExtrapolateType,\n  extrapolateRight?: ExtrapolateType,\n};\n\nvar linear = (t) => t;\n\n/**\n * Very handy helper to map input ranges to output ranges with an easing\n * function and custom behavior outside of the ranges.\n */\nclass Interpolation {\n  static create(config: InterpolationConfigType): (input: number) => number | string {\n\n    if (config.outputRange && typeof config.outputRange[0] === 'string') {\n      return createInterpolationFromStringOutputRange(config);\n    }\n\n    var outputRange: Array<number> = (config.outputRange: any);\n    checkInfiniteRange('outputRange', outputRange);\n\n    var inputRange = config.inputRange;\n    checkInfiniteRange('inputRange', inputRange);\n    checkValidInputRange(inputRange);\n\n    invariant(\n      inputRange.length === outputRange.length,\n      'inputRange (' + inputRange.length + ') and outputRange (' +\n      outputRange.length + ') must have the same length'\n    );\n\n    var easing = config.easing || linear;\n\n    var extrapolateLeft: ExtrapolateType = 'extend';\n    if (config.extrapolateLeft !== undefined) {\n      extrapolateLeft = config.extrapolateLeft;\n    } else if (config.extrapolate !== undefined) {\n      extrapolateLeft = config.extrapolate;\n    }\n\n    var extrapolateRight: ExtrapolateType = 'extend';\n    if (config.extrapolateRight !== undefined) {\n      extrapolateRight = config.extrapolateRight;\n    } else if (config.extrapolate !== undefined) {\n      extrapolateRight = config.extrapolate;\n    }\n\n    return (input) => {\n      invariant(\n        typeof input === 'number',\n        'Cannot interpolation an input which is not a number'\n      );\n\n      var range = findRange(input, inputRange);\n      return interpolate(\n        input,\n        inputRange[range],\n        inputRange[range + 1],\n        outputRange[range],\n        outputRange[range + 1],\n        easing,\n        extrapolateLeft,\n        extrapolateRight,\n      );\n    };\n  }\n}\n\nfunction interpolate(\n  input: number,\n  inputMin: number,\n  inputMax: number,\n  outputMin: number,\n  outputMax: number,\n  easing: ((input: number) => number),\n  extrapolateLeft: ExtrapolateType,\n  extrapolateRight: ExtrapolateType,\n) {\n  var result = input;\n\n  // Extrapolate\n  if (result < inputMin) {\n    if (extrapolateLeft === 'identity') {\n      return result;\n    } else if (extrapolateLeft === 'clamp') {\n      result = inputMin;\n    } else if (extrapolateLeft === 'extend') {\n      // noop\n    }\n  }\n\n  if (result > inputMax) {\n    if (extrapolateRight === 'identity') {\n      return result;\n    } else if (extrapolateRight === 'clamp') {\n      result = inputMax;\n    } else if (extrapolateRight === 'extend') {\n      // noop\n    }\n  }\n\n  if (outputMin === outputMax) {\n    return outputMin;\n  }\n\n  if (inputMin === inputMax) {\n    if (input <= inputMin) {\n      return outputMin;\n    }\n    return outputMax;\n  }\n\n  // Input Range\n  if (inputMin === -Infinity) {\n    result = -result;\n  } else if (inputMax === Infinity) {\n    result = result - inputMin;\n  } else {\n    result = (result - inputMin) / (inputMax - inputMin);\n  }\n\n  // Easing\n  result = easing(result);\n\n  // Output Range\n  if (outputMin === -Infinity) {\n    result = -result;\n  } else if (outputMax === Infinity) {\n    result = result + outputMin;\n  } else {\n    result = result * (outputMax - outputMin) + outputMin;\n  }\n\n  return result;\n}\n\nfunction colorToRgba(input: string): string {\n  var int32Color = normalizeColor(input);\n  if (int32Color === null) {\n    return input;\n  }\n\n  int32Color = int32Color || 0;\n\n  var r = (int32Color & 0xff000000) >>> 24;\n  var g = (int32Color & 0x00ff0000) >>> 16;\n  var b = (int32Color & 0x0000ff00) >>> 8;\n  var a = (int32Color & 0x000000ff) / 255;\n\n  return `rgba(${r}, ${g}, ${b}, ${a})`;\n}\n\nvar stringShapeRegex = /[0-9\\.-]+/g;\n\n/**\n * Supports string shapes by extracting numbers so new values can be computed,\n * and recombines those values into new strings of the same shape.  Supports\n * things like:\n *\n *   rgba(123, 42, 99, 0.36) // colors\n *   -45deg                  // values with units\n */\nfunction createInterpolationFromStringOutputRange(\n  config: InterpolationConfigType,\n): (input: number) => string {\n  var outputRange: Array<string> = (config.outputRange: any);\n  invariant(outputRange.length >= 2, 'Bad output range');\n  outputRange = outputRange.map(colorToRgba);\n  checkPattern(outputRange);\n\n  // ['rgba(0, 100, 200, 0)', 'rgba(50, 150, 250, 0.5)']\n  // ->\n  // [\n  //   [0, 50],\n  //   [100, 150],\n  //   [200, 250],\n  //   [0, 0.5],\n  // ]\n  /* $FlowFixMe(>=0.18.0): `outputRange[0].match()` can return `null`. Need to\n   * guard against this possibility.\n   */\n  var outputRanges = outputRange[0].match(stringShapeRegex).map(() => []);\n  outputRange.forEach(value => {\n    /* $FlowFixMe(>=0.18.0): `value.match()` can return `null`. Need to guard\n     * against this possibility.\n     */\n    value.match(stringShapeRegex).forEach((number, i) => {\n      outputRanges[i].push(+number);\n    });\n  });\n\n  /* $FlowFixMe(>=0.18.0): `outputRange[0].match()` can return `null`. Need to\n   * guard against this possibility.\n   */\n  var interpolations = outputRange[0].match(stringShapeRegex).map((value, i) => {\n    return Interpolation.create({\n      ...config,\n      outputRange: outputRanges[i],\n    });\n  });\n\n  // rgba requires that the r,g,b are integers.... so we want to round them, but we *dont* want to\n  // round the opacity (4th column).\n  const shouldRound = isRgbOrRgba(outputRange[0]);\n\n  return (input) => {\n    var i = 0;\n    // 'rgba(0, 100, 200, 0)'\n    // ->\n    // 'rgba(${interpolations[0](input)}, ${interpolations[1](input)}, ...'\n    return outputRange[0].replace(stringShapeRegex, () => {\n      const val = +interpolations[i++](input);\n      const rounded = shouldRound && i < 4 ? Math.round(val) : Math.round(val * 1000) / 1000;\n      return String(rounded);\n    });\n  };\n}\n\nfunction isRgbOrRgba(range) {\n  return typeof range === 'string' && range.startsWith('rgb');\n}\n\nfunction checkPattern(arr: Array<string>) {\n  var pattern = arr[0].replace(stringShapeRegex, '');\n  for (var i = 1; i < arr.length; ++i) {\n    invariant(\n      pattern === arr[i].replace(stringShapeRegex, ''),\n      'invalid pattern ' + arr[0] + ' and ' + arr[i],\n    );\n  }\n}\n\nfunction findRange(input: number, inputRange: Array<number>) {\n  for (var i = 1; i < inputRange.length - 1; ++i) {\n    if (inputRange[i] >= input) {\n      break;\n    }\n  }\n  return i - 1;\n}\n\nfunction checkValidInputRange(arr: Array<number>) {\n  invariant(arr.length >= 2, 'inputRange must have at least 2 elements');\n  for (var i = 1; i < arr.length; ++i) {\n    invariant(\n      arr[i] >= arr[i - 1],\n      /* $FlowFixMe(>=0.13.0) - In the addition expression below this comment,\n       * one or both of the operands may be something that doesn't cleanly\n       * convert to a string, like undefined, null, and object, etc. If you really\n       * mean this implicit string conversion, you can do something like\n       * String(myThing)\n       */\n      'inputRange must be monotonically increasing ' + arr\n    );\n  }\n}\n\nfunction checkInfiniteRange(name: string, arr: Array<number>) {\n  invariant(arr.length >= 2, name + ' must have at least 2 elements');\n  invariant(\n    arr.length !== 2 || arr[0] !== -Infinity || arr[1] !== Infinity,\n    /* $FlowFixMe(>=0.13.0) - In the addition expression below this comment,\n     * one or both of the operands may be something that doesn't cleanly convert\n     * to a string, like undefined, null, and object, etc. If you really mean\n     * this implicit string conversion, you can do something like\n     * String(myThing)\n     */\n    name + 'cannot be ]-infinity;+infinity[ ' + arr\n  );\n}\n\nmodule.exports = Interpolation;\n"]}]