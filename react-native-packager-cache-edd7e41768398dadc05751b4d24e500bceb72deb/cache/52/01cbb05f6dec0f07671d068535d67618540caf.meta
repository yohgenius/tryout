["19798d757b63fe3b73e3fdf26237621a692bf3fc","f5f7c58e30c65c9924b27c57971af6e6677f10dc",["fbjs/lib/invariant"],[40],{"version":3,"sources":["/TryOut/node_modules/react-native/Libraries/Performance/Systrace.js"],"names":["invariant","require","TRACE_TAG_REACT_APPS","TRACE_TAG_JSC_CALLS","_enabled","_asyncCookie","_markStack","_markStackIndex","REACT_MARKER","userTimingPolyfill","mark","markName","__DEV__","systraceLabel","indexOfId","lastIndexOf","cutoffIndex","length","slice","Systrace","beginEvent","measure","measureName","startMark","endMark","topMark","endEvent","clearMarks","clearMeasures","getUserTimingPolyfill","setEnabled","enabled","global","nativeTraceBeginLegacy","nativeTraceEndLegacy","isEnabled","profileName","args","nativeTraceBeginSection","nativeTraceEndSection","beginAsyncEvent","cookie","nativeTraceBeginAsyncSection","endAsyncEvent","nativeTraceEndAsyncSection","counterEvent","value","nativeTraceCounter","attachToRelayProfiler","relayProfiler","attachProfileHandler","name","attachAggregateHandler","callback","swizzleJSON","measureMethods","JSON","object","objectName","methodNames","forEach","methodName","objName","fnName","func","apply","arguments","ret","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) 2015-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule Systrace\n * @flow\n */\n'use strict';\n\nconst invariant = require('fbjs/lib/invariant');\n\ntype RelayProfiler = {\n  attachProfileHandler(\n    name: string,\n    handler: (name: string, state?: any) => () => void\n  ): void,\n\n  attachAggregateHandler(\n    name: string,\n    handler: (name: string, callback: () => void) => void\n  ): void,\n};\n\n/* eslint no-bitwise: 0 */\nconst TRACE_TAG_REACT_APPS = 1 << 17;\nconst TRACE_TAG_JSC_CALLS = 1 << 27;\n\nlet _enabled = false;\nlet _asyncCookie = 0;\nconst _markStack = [];\nlet _markStackIndex = -1;\n\n// Implements a subset of User Timing API necessary for React measurements.\n// https://developer.mozilla.org/en-US/docs/Web/API/User_Timing_API\nconst REACT_MARKER = '\\u269B';\nconst userTimingPolyfill = {\n  mark(markName: string) {\n    if (__DEV__) {\n      if (_enabled) {\n        _markStackIndex++;\n        _markStack[_markStackIndex] = markName;\n        let systraceLabel = markName;\n        // Since perf measurements are a shared namespace in User Timing API,\n        // we prefix all React results with a React emoji.\n        if (markName[0] === REACT_MARKER) {\n          // This is coming from React.\n          // Removing component IDs keeps trace colors stable.\n          const indexOfId = markName.lastIndexOf(' (#');\n          const cutoffIndex = indexOfId !== -1 ? indexOfId : markName.length;\n          // Also cut off the emoji because it breaks Systrace\n          systraceLabel = markName.slice(2, cutoffIndex);\n        }\n        Systrace.beginEvent(systraceLabel);\n      }\n    }\n  },\n  measure(measureName: string, startMark: ?string, endMark: ?string) {\n    if (__DEV__) {\n      if (_enabled) {\n        invariant(\n          typeof measureName === 'string' &&\n          typeof startMark === 'string' &&\n          typeof endMark === 'undefined',\n          'Only performance.measure(string, string) overload is supported.'\n        );\n        const topMark = _markStack[_markStackIndex];\n        invariant(\n          startMark === topMark,\n          'There was a mismatching performance.measure() call. ' +\n          'Expected \"%s\" but got \"%s.\"',\n          topMark,\n          startMark,\n        );\n        _markStackIndex--;\n        // We can't use more descriptive measureName because Systrace doesn't\n        // let us edit labels post factum.\n        Systrace.endEvent();\n      }\n    }\n  },\n  clearMarks(markName: string) {\n    if (__DEV__) {\n      if (_enabled) {\n        if (_markStackIndex === -1) {\n          return;\n        }\n        if (markName === _markStack[_markStackIndex]) {\n          // React uses this for \"cancelling\" started measurements.\n          // Systrace doesn't support deleting measurements, so we just stop them.\n          userTimingPolyfill.measure(markName, markName);\n        }\n      }\n    }\n  },\n  clearMeasures() {\n    // React calls this to avoid memory leaks in browsers, but we don't keep\n    // measurements anyway.\n  },\n};\n\nconst Systrace = {\n  getUserTimingPolyfill() {\n    return userTimingPolyfill;\n  },\n\n  setEnabled(enabled: boolean) {\n    if (_enabled !== enabled) {\n      if (__DEV__) {\n        if (enabled) {\n          global.nativeTraceBeginLegacy && global.nativeTraceBeginLegacy(TRACE_TAG_JSC_CALLS);\n        } else {\n          global.nativeTraceEndLegacy && global.nativeTraceEndLegacy(TRACE_TAG_JSC_CALLS);\n        }\n      }\n      _enabled = enabled;\n    }\n  },\n\n  isEnabled(): boolean {\n    return _enabled;\n  },\n\n  /**\n   * beginEvent/endEvent for starting and then ending a profile within the same call stack frame\n  **/\n  beginEvent(profileName?: any, args?: any) {\n    if (_enabled) {\n      profileName = typeof profileName === 'function' ?\n        profileName() : profileName;\n      global.nativeTraceBeginSection(TRACE_TAG_REACT_APPS, profileName, args);\n    }\n  },\n\n  endEvent() {\n    if (_enabled) {\n      global.nativeTraceEndSection(TRACE_TAG_REACT_APPS);\n    }\n  },\n\n  /**\n   * beginAsyncEvent/endAsyncEvent for starting and then ending a profile where the end can either\n   * occur on another thread or out of the current stack frame, eg await\n   * the returned cookie variable should be used as input into the endAsyncEvent call to end the profile\n  **/\n  beginAsyncEvent(profileName?: any): any {\n    const cookie = _asyncCookie;\n    if (_enabled) {\n      _asyncCookie++;\n      profileName = typeof profileName === 'function' ?\n        profileName() : profileName;\n      global.nativeTraceBeginAsyncSection(TRACE_TAG_REACT_APPS, profileName, cookie, 0);\n    }\n    return cookie;\n  },\n\n  endAsyncEvent(profileName?: any, cookie?: any) {\n    if (_enabled) {\n      profileName = typeof profileName === 'function' ?\n        profileName() : profileName;\n      global.nativeTraceEndAsyncSection(TRACE_TAG_REACT_APPS, profileName, cookie, 0);\n    }\n  },\n\n  /**\n   * counterEvent registers the value to the profileName on the systrace timeline\n  **/\n  counterEvent(profileName?: any, value?: any) {\n    if (_enabled) {\n      profileName = typeof profileName === 'function' ?\n        profileName() : profileName;\n      global.nativeTraceCounter &&\n        global.nativeTraceCounter(TRACE_TAG_REACT_APPS, profileName, value);\n    }\n  },\n\n  /**\n   * Relay profiles use await calls, so likely occur out of current stack frame\n   * therefore async variant of profiling is used\n  **/\n  attachToRelayProfiler(relayProfiler: RelayProfiler) {\n    relayProfiler.attachProfileHandler('*', (name) => {\n      const cookie = Systrace.beginAsyncEvent(name);\n      return () => {\n        Systrace.endAsyncEvent(name, cookie);\n      };\n    });\n\n    relayProfiler.attachAggregateHandler('*', (name, callback) => {\n      Systrace.beginEvent(name);\n      callback();\n      Systrace.endEvent();\n    });\n  },\n\n  /* This is not called by default due to perf overhead but it's useful\n     if you want to find traces which spend too much time in JSON. */\n  swizzleJSON() {\n    Systrace.measureMethods(JSON, 'JSON', [\n      'parse',\n      'stringify'\n    ]);\n  },\n\n /**\n  * Measures multiple methods of a class. For example, you can do:\n  * Systrace.measureMethods(JSON, 'JSON', ['parse', 'stringify']);\n  *\n  * @param object\n  * @param objectName\n  * @param methodNames Map from method names to method display names.\n  */\n measureMethods(object: any, objectName: string, methodNames: Array<string>): void {\n   if (!__DEV__) {\n     return;\n   }\n\n   methodNames.forEach(methodName => {\n     object[methodName] = Systrace.measure(\n       objectName,\n       methodName,\n       object[methodName]\n     );\n   });\n },\n\n /**\n  * Returns an profiled version of the input function. For example, you can:\n  * JSON.parse = Systrace.measure('JSON', 'parse', JSON.parse);\n  *\n  * @param objName\n  * @param fnName\n  * @param {function} func\n  * @return {function} replacement function\n  */\n measure(objName: string, fnName: string, func: any): any {\n   if (!__DEV__) {\n     return func;\n   }\n\n   const profileName = `${objName}.${fnName}`;\n   return function() {\n     if (!_enabled) {\n       return func.apply(this, arguments);\n     }\n\n     Systrace.beginEvent(profileName);\n     const ret = func.apply(this, arguments);\n     Systrace.endEvent();\n     return ret;\n   };\n },\n};\n\nif (__DEV__) {\n  // This is needed, because require callis in polyfills are not processed as\n  // other files. Therefore, calls to `require('moduleId')` are not replaced\n  // with numeric IDs\n  // TODO(davidaurelio) Scan polyfills for dependencies, too (t9759686)\n  (require: any).Systrace = Systrace;\n}\n\nmodule.exports = Systrace;\n"]}]